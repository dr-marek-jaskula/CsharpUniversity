## Entity Framework Core University

This is a Entity Framework Core tutorial with many separated models and configurations.
Comments are used in much intense, even if in a commercial application they should be only used if there is no other way to improve code readability.

Entity Framework Core primary goal is reliable execution. The performance is not the most important. If the performance is of the most importance, use Dapper.

## Class library project

In order to create a separate project that deals with database, we need to:
- create new "Class Library" project
- install: Microsoft.EntityFrameworkCore.SqlServer or MySql.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Design (for migrations), Microsoft.Extensions.Configuration.Json (for appsettings)
- add appsettings.json
- set appsettings.json properties to "Copy if newer" (or always copy)
- install the latest version of [dotnet ef](https://www.nuget.org/packages/dotnet-ef/):
> dotnet tool install --global dotnet-ef --version 6.0.3
or update to last version
> dotnet tool update --global dotnet-ef --version 6.0.3
- add DbContext (in this project it is called "MyDbContext")
- add data context factory, here called "MyDbContextFactory"
- add the connection string to the appsettings.json:
	- to connect to MySql: "Server=localhost;Database=CedrusMechanic;Uid=root;Pwd=DataBase;"
	- to connect to MS Sql Server: "Server=(localdb)\\MSSQLLocalDB;Database=ShareForFuture;Trusted_Connection=True"

If we are using MS SQL Server we can open "SQL Server Object Explorer" and "Server Explorer" to get for example the connection string
Check local dbs:
> sqllocaldb i

Get info about specified local db:
> sqllocaldb i MSSQLLocalDB  

Create a new local db called "dev" (it will make a new local db with newest version). Use if there is a need.
> sqllocaldb c dev 

Check in Azure Data Studio the connection:
> (localdb)\dev

- create data models
- configure data models
	- check "Review" configuration to see DefaultValues and .ValueGeneratedOnAddOrUpdate() - Generate value when the update is made and when data is added
	- check "Role" configuration to see inserting static data (that are not related to other)
- Open the power shell (or other CLI), we go to directory where there internal class library is and then:
> dotnet ef migrations add Init
where "Init" is the migration name

If we want to see the SQL statement that is generated by the migrations we can use:
> dotnet ef migrations script --output migrate.sql
This will generate the file **migrate.sql** in which all SQL statements are present

- apply migrations to the database by:
> dotnet ef database update

## Revert migrations

To revert lastly applied migrations:
> dotnet ef database update <previous-migration-name>

To revert all migrations
> dotnet ef database update 0
> dotnet ef migrations remove
and delete migrations folder

## Data models and configurations

- make separation between models and configurations
- prefer to make nullable properties
- make nullable references and nullable id references (like ProductId)
- make all model references virtual properties
- make all multiple references (lists) set to default value new()

#### Many-to-many relationship by default

To obtain many to many relationship, we should add class like Salary_Transfer. 
We can omit it, but then the ef core will create an auto-generated table for that purpose.

**The best way** is to use the direct relation in c# code, but still keep the helper tables. 
This approach is made in OnModelCreating of MyDbContext class. 

#### Naming conventions

Use PascalCase for table names. but for tables that are used to define the many-to-many relationship use underscored PascalCase: Salary_Transfer

#### Diagram

In order to illustrate the relations, we can create a ModelDiagram:
- install an extension by Visual Studio Installer (class diagram)
- add a ModelDiagram.cd element 
- fill it will model classes.

#### Basic performance

- use normalization (1, 2 and 3 normal form)
- prefer to use SMALLINT or TINYINT instead of INT if it is possible
- prefer to use VARCHAR with minimal possible number of bytes
- try to build rows (column definition) that would take memory equal to any divider of the page size (8kb, 8096bytes, because rest is Page Header)
	- page is a minimal amount of data in mssql, it is 8kb. If a row takes like 5kb, then 3kb will be waste. If a row takes 4kb, then two rows can be stored in one page and no memory is waste
- store a multiplication of one extent (8 pages = 64kb).
	- The least that can be retried is one extent so 64kb. Try not to get data that takes like 1/3 of extent.

## Additional informations

To fill the table with random data use Bogus NuGet Package 

To read more about EF Core features, performance issues (for instance bulkUpdates, safe raw sql interpolation) and traps, go to: EF Core advance 

To use DateOnly instead of DateTime see "Helpers" (Person, User) classes

For **owned types**, see Address class

For **views**, see View folder

## Code First vs Database First

The preferred way is to use Database First approach. 

Use Code First for smaller projects or when we need to do something fast.
When doing Code First be aware that we can not use so advanced database feature like "table partitioning".

## Tips and rules

- use Tags by WithTag method to clarify the query in the logs

- use CancellationToken to stop the query on the database side if required. This is very important

- sometimes use bulk processing in chunks

- if needed use raw sql, but try to avoid it